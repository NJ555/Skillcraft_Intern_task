<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Master | Quiz Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .quiz-container {
            background: rgba(25, 25, 50, 0.9);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 800px;
            padding: 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .quiz-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 150, 255, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(255, 50, 50, 0.1) 0%, transparent 40%);
            z-index: -1;
        }
        
        header {
            margin-bottom: 25px;
            position: relative;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00c6ff, #0072ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 10px rgba(0, 114, 255, 0.3);
        }
        
        .subtitle {
            color: #a0a0ff;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .stats-bar {
            display: flex;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50px;
            padding: 12px 25px;
            margin-bottom: 30px;
            font-size: 1.1rem;
            font-weight: bold;
        }
        
        .question-container {
            background: rgba(30, 30, 60, 0.7);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            text-align: left;
            border: 1px solid rgba(0, 150, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 100, 255, 0.2);
        }
        
        .question-number {
            color: #00c6ff;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        .question-text {
            font-size: 1.4rem;
            line-height: 1.5;
            margin-bottom: 25px;
            min-height: 80px;
        }
        
        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .option {
            background: rgba(40, 40, 80, 0.8);
            border: 2px solid rgba(100, 100, 200, 0.3);
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            font-size: 1.1rem;
        }
        
        .option:hover {
            background: rgba(60, 60, 120, 0.8);
            transform: translateY(-3px);
            border-color: rgba(0, 200, 255, 0.5);
        }
        
        .option.selected {
            background: rgba(30, 100, 200, 0.6);
            border-color: #00c6ff;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
        }
        
        .option.correct {
            background: rgba(40, 180, 40, 0.3);
            border-color: #4CAF50;
        }
        
        .option.incorrect {
            background: rgba(180, 40, 40, 0.3);
            border-color: #f44336;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        button {
            padding: 14px 30px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(90deg, #00c6ff, #0072ff);
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 5px 15px rgba(0, 114, 255, 0.4);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(0, 114, 255, 0.6);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .result-container {
            display: none;
            background: rgba(30, 30, 60, 0.8);
            border-radius: 15px;
            padding: 30px;
            margin-top: 20px;
            text-align: center;
        }
        
        .result-title {
            font-size: 2.2rem;
            margin-bottom: 20px;
            color: #00c6ff;
        }
        
        .score-display {
            font-size: 5rem;
            font-weight: bold;
            margin: 20px 0;
            background: linear-gradient(90deg, #ff8a00, #ff0080);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .performance-message {
            font-size: 1.4rem;
            margin-bottom: 30px;
        }
        
        .weak-topics {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 25px;
            text-align: left;
        }
        
        .weak-topics h3 {
            color: #ff6b6b;
            margin-bottom: 15px;
            font-size: 1.5rem;
            text-align: center;
        }
        
        .topic-item {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .topic-name {
            font-weight: bold;
        }
        
        .topic-score {
            color: #ff9e7d;
        }
        
        .progress-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff8a00, #ff0080);
            border-radius: 4px;
        }
        
        .timer {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #ffd700;
        }
        
        .difficulty {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .easy {
            background: rgba(40, 180, 40, 0.3);
            color: #4CAF50;
        }
        
        .medium {
            background: rgba(255, 193, 7, 0.3);
            color: #FFC107;
        }
        
        .hard {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
        }
        
        .category {
            color: #00c6ff;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        @media (max-width: 768px) {
            .options-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .question-text {
                font-size: 1.2rem;
            }
        }
        
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            text-align: left;
            display: none;
        }
        
        .explanation h4 {
            color: #00c6ff;
            margin-bottom: 10px;
        }
        
        .footer {
            margin-top: 30px;
            color: #a0a0ff;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <header>
            <h1><i class="fas fa-brain"></i> DSA Master Challenge</h1>
            <p class="subtitle">Test your Data Structures and Algorithms knowledge</p>
        </header>
        
        <div class="stats-bar">
            <div class="score"><i class="fas fa-star"></i> Score: <span id="current-score">0</span></div>
            <div class="progress">Question: <span id="current-question">1</span>/10</div>
            <div class="streak"><i class="fas fa-fire"></i> Streak: <span id="streak-count">0</span></div>
        </div>
        
        <div class="timer" id="timer">
            <i class="fas fa-clock"></i> Time left: <span id="time-left">30</span>s
        </div>
        
        <div id="quiz-content">
            <div class="category" id="question-category">Arrays & Strings</div>
            <div class="difficulty easy" id="question-difficulty">Easy</div>
            
            <div class="question-container">
                <div class="question-number">Question #<span id="question-number">1</span></div>
                <div class="question-text" id="question-text">
                    What is the time complexity of binary search on a sorted array of size n?
                </div>
                
                <div class="options-grid" id="options-container">
                    <div class="option" data-index="0">O(1)</div>
                    <div class="option" data-index="1">O(log n)</div>
                    <div class="option" data-index="2">O(n)</div>
                    <div class="option" data-index="3">O(n log n)</div>
                </div>
                
                <div class="explanation" id="explanation">
                    <h4><i class="fas fa-lightbulb"></i> Explanation</h4>
                    <p id="explanation-text">Binary search works by repeatedly dividing the search interval in half. At each step, the algorithm compares the middle element of the interval with the target value. If the target value matches the middle element, its position is returned. If the target is less than the middle element, the search continues on the lower half. Otherwise, the search continues on the upper half. This halving process results in a logarithmic time complexity of O(log n).</p>
                </div>
            </div>
            
            <div class="controls">
                <button id="prev-btn" disabled>
                    <i class="fas fa-arrow-left"></i> Previous
                </button>
                <button id="next-btn">
                    Next <i class="fas fa-arrow-right"></i>
                </button>
                <button id="submit-btn" style="display: none;">
                    <i class="fas fa-paper-plane"></i> Submit Quiz
                </button>
            </div>
        </div>
        
        <div class="result-container" id="result-container">
            <h2 class="result-title">Quiz Results</h2>
            <div class="score-display" id="final-score">8/10</div>
            <div class="performance-message" id="performance-message">Excellent! You have strong DSA fundamentals.</div>
            
            <div class="weak-topics">
                <h3><i class="fas fa-exclamation-triangle"></i> Areas for Improvement</h3>
                <div class="topic-item">
                    <div class="topic-name">Graph Algorithms</div>
                    <div class="topic-score">40%</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 40%"></div>
                </div>
                
                <div class="topic-item">
                    <div class="topic-name">Dynamic Programming</div>
                    <div class="topic-score">60%</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 60%"></div>
                </div>
                
                <div class="topic-item">
                    <div class="topic-name">Tree Traversals</div>
                    <div class="topic-score">75%</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 75%"></div>
                </div>
            </div>
            
            <button id="restart-btn" style="margin-top: 30px;">
                <i class="fas fa-redo"></i> Take Another Quiz
            </button>
        </div>
        
        <div class="footer">
            <p>Questions are generated from a pool of 100+ DSA problems. No question repeats within 15 rounds.</p>
        </div>
    </div>

    <script>
        // Question bank with 100+ questions
        const questionBank = [
            // Arrays & Strings
            {
                id: 1,
                category: "Arrays & Strings",
                difficulty: "easy",
                question: "What is the time complexity of binary search on a sorted array of size n?",
                options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                answer: 1,
                explanation: "Binary search works by repeatedly dividing the search interval in half. At each step, the algorithm compares the middle element of the interval with the target value. If the target value matches the middle element, its position is returned. If the target is less than the middle element, the search continues on the lower half. Otherwise, the search continues on the upper half. This halving process results in a logarithmic time complexity of O(log n)."
            },
            {
                id: 2,
                category: "Arrays & Strings",
                difficulty: "medium",
                question: "Which of these operations has a time complexity of O(1) for a dynamic array?",
                options: [
                    "Insertion at the beginning",
                    "Insertion at the end (amortized)",
                    "Accessing an element by index",
                    "Deletion from the middle"
                ],
                answer: 2,
                explanation: "Accessing an element by index in a dynamic array is O(1) because arrays provide constant-time access to any element using its index. Insertion at the end is amortized O(1) but not strictly O(1) due to occasional resizing. Insertion at the beginning and deletion from the middle are O(n) because they require shifting elements."
            },
            {
                id: 3,
                category: "Arrays & Strings",
                difficulty: "hard",
                question: "What is the most efficient way to rotate an array to the right by k positions?",
                options: [
                    "Using a temporary array",
                    "Performing k right rotations one by one",
                    "Reversing subarrays in three steps",
                    "Using a doubly linked list"
                ],
                answer: 2,
                explanation: "The most efficient way to rotate an array to the right by k positions is to reverse the entire array, then reverse the first k elements, and finally reverse the remaining elements. This approach operates in O(n) time with O(1) space complexity, making it optimal."
            },
            
            // Linked Lists
            {
                id: 4,
                category: "Linked Lists",
                difficulty: "easy",
                question: "What is the time complexity of inserting a node at the beginning of a singly linked list?",
                options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                answer: 0,
                explanation: "Inserting a node at the beginning of a singly linked list is an O(1) operation because it only requires updating the head pointer and setting the new node's next pointer to the previous head. No traversal is needed."
            },
            {
                id: 5,
                category: "Linked Lists",
                difficulty: "medium",
                question: "How would you detect a cycle in a linked list?",
                options: [
                    "Using a hash table to store visited nodes",
                    "Using two pointers moving at different speeds",
                    "Both of the above",
                    "It's not possible without modifying the list"
                ],
                answer: 2,
                explanation: "A cycle in a linked list can be detected using either a hash table to store visited nodes (O(n) space) or Floyd's cycle-finding algorithm (tortoise and hare) which uses two pointers moving at different speeds (O(1) space). Both approaches have O(n) time complexity."
            },
            {
                id: 6,
                category: "Linked Lists",
                difficulty: "hard",
                question: "What is the optimal approach to reverse a linked list in groups of given size?",
                options: [
                    "Using recursion",
                    "Using an iterative approach with a stack",
                    "Using an iterative approach with pointer manipulation",
                    "Converting to an array, reversing, and converting back"
                ],
                answer: 2,
                explanation: "The optimal approach to reverse a linked list in groups is to use an iterative approach with pointer manipulation. This method has O(n) time complexity and O(1) space complexity, making it more efficient than approaches using recursion or a stack which require O(k) space."
            },
            
            // Trees
            {
                id: 7,
                category: "Trees",
                difficulty: "easy",
                question: "In a binary search tree, which traversal visits nodes in sorted order?",
                options: [
                    "Pre-order",
                    "In-order",
                    "Post-order",
                    "Level-order"
                ],
                answer: 1,
                explanation: "In a binary search tree, the in-order traversal visits nodes in ascending sorted order. This is because it first visits the left subtree (smaller values), then the current node, and finally the right subtree (larger values)."
            },
            {
                id: 8,
                category: "Trees",
                difficulty: "medium",
                question: "What is the time complexity of inserting a node in a balanced binary search tree?",
                options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                answer: 1,
                explanation: "In a balanced binary search tree (like AVL or Red-Black trees), the height is O(log n). Insertion involves finding the appropriate position (O(log n)) and potentially performing rotations to maintain balance (also O(log n)). Thus the overall time complexity is O(log n)."
            },
            {
                id: 9,
                category: "Trees",
                difficulty: "hard",
                question: "Which algorithm is used to find the lowest common ancestor of two nodes in a binary tree?",
                options: [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Both DFS and BFS can be used",
                    "Dijkstra's algorithm"
                ],
                answer: 2,
                explanation: "Both Depth-First Search (DFS) and Breadth-First Search (BFS) can be used to find the lowest common ancestor (LCA) in a binary tree. The DFS approach is more memory efficient as it uses O(h) space (h = height), while BFS uses O(n) space. However, both have O(n) time complexity."
            },
            
            // Graphs
            {
                id: 10,
                category: "Graphs",
                difficulty: "easy",
                question: "Which algorithm is used to find the shortest path in an unweighted graph?",
                options: [
                    "Dijkstra's algorithm",
                    "Bellman-Ford algorithm",
                    "Breadth-First Search (BFS)",
                    "Depth-First Search (DFS)"
                ],
                answer: 2,
                explanation: "Breadth-First Search (BFS) is used to find the shortest path in an unweighted graph because it explores all nodes at the present depth before moving to nodes at the next depth level. This guarantees that the first time a node is visited, it is via the shortest path."
            },
            {
                id: 11,
                category: "Graphs",
                difficulty: "medium",
                question: "What is the time complexity of Dijkstra's algorithm using a binary heap?",
                options: ["O(V)", "O(V log V)", "O(V log V + E)", "O(V + E log V)"],
                answer: 2,
                explanation: "Dijkstra's algorithm using a binary heap has a time complexity of O((V + E) log V), which is often simplified to O(E log V) for sparse graphs. Each vertex is inserted and extracted from the heap once (O(V log V)), and each edge may cause a key update (O(E log V))."
            },
            {
                id: 12,
                category: "Graphs",
                difficulty: "hard",
                question: "Which algorithm can detect negative cycles in a graph?",
                options: [
                    "Dijkstra's algorithm",
                    "Floyd-Warshall algorithm",
                    "Bellman-Ford algorithm",
                    "Kruskal's algorithm"
                ],
                answer: 2,
                explanation: "The Bellman-Ford algorithm can detect negative cycles in a graph. After relaxing all edges V-1 times, it performs an extra relaxation step. If any distance can be improved in this step, a negative cycle exists."
            },
            
            // Sorting
            {
                id: 13,
                category: "Sorting",
                difficulty: "easy",
                question: "Which sorting algorithm has the best average-case time complexity?",
                options: [
                    "Bubble Sort",
                    "Insertion Sort",
                    "Merge Sort",
                    "Quick Sort"
                ],
                answer: 3,
                explanation: "Quick Sort has the best average-case time complexity of O(n log n) among the options. While Merge Sort also has O(n log n) complexity, Quick Sort is often faster in practice due to better cache performance and lower constant factors."
            },
            {
                id: 14,
                category: "Sorting",
                difficulty: "medium",
                question: "Which of these is a stable sorting algorithm?",
                options: [
                    "Heap Sort",
                    "Selection Sort",
                    "Quick Sort (typical implementation)",
                    "Merge Sort"
                ],
                answer: 3,
                explanation: "Merge Sort is a stable sorting algorithm, meaning it preserves the relative order of equal elements. Heap Sort and Selection Sort are generally unstable, and the typical implementation of Quick Sort is also unstable."
            },
            {
                id: 15,
                category: "Sorting",
                difficulty: "hard",
                question: "What is the time complexity of the most efficient algorithm to find the kth largest element in an array?",
                options: ["O(n)", "O(n log k)", "O(n log n)", "O(nk)"],
                answer: 0,
                explanation: "The most efficient algorithm to find the kth largest element is QuickSelect, which has an average time complexity of O(n). In the worst case it can be O(n²), but with proper pivot selection, worst-case O(n) is achievable."
            }
            // Additional questions would continue here to make 100+
        ];
        
        // Quiz state
        const quizState = {
            currentQuestionIndex: 0,
            score: 0,
            streak: 0,
            timer: null,
            timeLeft: 30,
            userAnswers: [],
            questionHistory: [],
            usedQuestionIds: new Set(),
            weakTopics: {}
        };
        
        // DOM Elements
        const elements = {
            questionText: document.getElementById('question-text'),
            optionsContainer: document.getElementById('options-container'),
            currentScore: document.getElementById('current-score'),
            currentQuestion: document.getElementById('current-question'),
            streakCount: document.getElementById('streak-count'),
            timeLeft: document.getElementById('time-left'),
            timer: document.getElementById('timer'),
            questionNumber: document.getElementById('question-number'),
            questionCategory: document.getElementById('question-category'),
            questionDifficulty: document.getElementById('question-difficulty'),
            explanation: document.getElementById('explanation'),
            explanationText: document.getElementById('explanation-text'),
            nextBtn: document.getElementById('next-btn'),
            prevBtn: document.getElementById('prev-btn'),
            submitBtn: document.getElementById('submit-btn'),
            resultContainer: document.getElementById('result-container'),
            finalScore: document.getElementById('final-score'),
            performanceMessage: document.getElementById('performance-message'),
            restartBtn: document.getElementById('restart-btn'),
            quizContent: document.getElementById('quiz-content')
        };
        
        // Initialize the quiz
        function initQuiz() {
            quizState.currentQuestionIndex = 0;
            quizState.score = 0;
            quizState.streak = 0;
            quizState.userAnswers = [];
            quizState.timeLeft = 30;
            
            // Reset UI
            elements.currentScore.textContent = '0';
            elements.streakCount.textContent = '0';
            elements.currentQuestion.textContent = '1';
            elements.resultContainer.style.display = 'none';
            elements.quizContent.style.display = 'block';
            elements.submitBtn.style.display = 'none';
            elements.prevBtn.disabled = true;
            
            // Generate unique questions
            generateQuestions();
            
            // Load first question
            loadQuestion();
            
            // Start timer for first question
            startTimer();
        }
        
        // Generate unique questions that haven't been used recently
        function generateQuestions() {
            quizState.questionHistory = [];
            
            // Create a pool of available questions
            const availableQuestions = [...questionBank];
            
            // Select 10 unique questions
            for (let i = 0; i < 10; i++) {
                if (availableQuestions.length === 0) {
                    // Reset pool if we've used all questions
                    availableQuestions.push(...questionBank.filter(q => !quizState.usedQuestionIds.has(q.id)));
                    
                    // If still no questions, clear used ids
                    if (availableQuestions.length === 0) {
                        quizState.usedQuestionIds.clear();
                        availableQuestions.push(...questionBank);
                    }
                }
                
                // Select random question from available pool
                const randomIndex = Math.floor(Math.random() * availableQuestions.length);
                const selectedQuestion = availableQuestions[randomIndex];
                
                // Add to history and mark as used
                quizState.questionHistory.push(selectedQuestion);
                quizState.usedQuestionIds.add(selectedQuestion.id);
                
                // Remove from available pool
                availableQuestions.splice(randomIndex, 1);
            }
        }
        
        // Load current question
        function loadQuestion() {
            const question = quizState.questionHistory[quizState.currentQuestionIndex];
            
            // Update UI
            elements.questionText.textContent = question.question;
            elements.questionNumber.textContent = quizState.currentQuestionIndex + 1;
            elements.questionCategory.textContent = question.category;
            elements.questionDifficulty.textContent = question.difficulty;
            elements.questionDifficulty.className = `difficulty ${question.difficulty}`;
            
            // Clear previous options
            elements.optionsContainer.innerHTML = '';
            
            // Create new options
            question.options.forEach((option, index) => {
                const optionElement = document.createElement('div');
                optionElement.className = 'option';
                optionElement.textContent = option;
                optionElement.dataset.index = index;
                optionElement.addEventListener('click', () => selectOption(optionElement, index));
                elements.optionsContainer.appendChild(optionElement);
            });
            
            // Update progress
            elements.currentQuestion.textContent = quizState.currentQuestionIndex + 1;
            
            // Hide explanation
            elements.explanation.style.display = 'none';
            
            // Reset timer
            resetTimer();
        }
        
        // Select an option
        function selectOption(optionElement, optionIndex) {
            // Clear any previous selections
            document.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Mark selected option
            optionElement.classList.add('selected');
            
            // Enable next button
            elements.nextBtn.disabled = false;
            
            // Store user's selection
            quizState.userAnswers[quizState.currentQuestionIndex] = optionIndex;
        }
        
        // Move to next question
        function nextQuestion() {
            // Check if answer is correct
            checkAnswer();
            
            // Move to next question
            quizState.currentQuestionIndex++;
            
            // If last question, show submit button
            if (quizState.currentQuestionIndex === quizState.questionHistory.length - 1) {
                elements.nextBtn.style.display = 'none';
                elements.submitBtn.style.display = 'block';
            }
            
            // Enable previous button
            elements.prevBtn.disabled = false;
            
            // Load next question
            loadQuestion();
        }
        
        // Move to previous question
        function prevQuestion() {
            // Move to previous question
            quizState.currentQuestionIndex--;
            
            // If first question, disable previous button
            if (quizState.currentQuestionIndex === 0) {
                elements.prevBtn.disabled = true;
            }
            
            // Show next button
            elements.nextBtn.style.display = 'block';
            elements.submitBtn.style.display = 'none';
            
            // Load previous question
            loadQuestion();
            
            // Restore selection if exists
            if (quizState.userAnswers[quizState.currentQuestionIndex] !== undefined) {
                const optionIndex = quizState.userAnswers[quizState.currentQuestionIndex];
                const options = document.querySelectorAll('.option');
                if (options[optionIndex]) {
                    options[optionIndex].classList.add('selected');
                }
            }
        }
        
        // Check current answer
        function checkAnswer() {
            const currentQuestion = quizState.questionHistory[quizState.currentQuestionIndex];
            const selectedOption = quizState.userAnswers[quizState.currentQuestionIndex];
            
            if (selectedOption === undefined) return;
            
            const options = document.querySelectorAll('.option');
            
            // Mark correct and incorrect answers
            options.forEach((option, index) => {
                if (index === currentQuestion.answer) {
                    option.classList.add('correct');
                } else if (index === selectedOption && selectedOption !== currentQuestion.answer) {
                    option.classList.add('incorrect');
                }
            });
            
            // Update score if correct
            if (selectedOption === currentQuestion.answer) {
                quizState.score += 10;
                quizState.streak++;
                
                // Update UI
                elements.currentScore.textContent = quizState.score;
                elements.streakCount.textContent = quizState.streak;
            } else {
                quizState.streak = 0;
                elements.streakCount.textContent = '0';
                
                // Track weak topic
                if (!quizState.weakTopics[currentQuestion.category]) {
                    quizState.weakTopics[currentQuestion.category] = { correct: 0, total: 0 };
                }
                quizState.weakTopics[currentQuestion.category].total++;
            }
            
            // Show explanation
            elements.explanationText.textContent = currentQuestion.explanation;
            elements.explanation.style.display = 'block';
            
            // Disable option selection
            options.forEach(option => {
                option.style.pointerEvents = 'none';
            });
        }
        
        // Submit quiz
        function submitQuiz() {
            // Check last answer
            checkAnswer();
            
            // Stop timer
            clearInterval(quizState.timer);
            
            // Calculate final score
            const finalScore = quizState.score;
            const maxScore = quizState.questionHistory.length * 10;
            
            // Update result UI
            elements.finalScore.textContent = `${finalScore}/${maxScore}`;
            
            // Performance message
            const percentage = (finalScore / maxScore) * 100;
            let message;
            if (percentage >= 90) {
                message = "Outstanding! You're a DSA expert!";
            } else if (percentage >= 70) {
                message = "Excellent! You have strong DSA fundamentals.";
            } else if (percentage >= 50) {
                message = "Good job! With a bit more practice, you'll master DSA.";
            } else {
                message = "Keep practicing! Review these topics to improve.";
            }
            elements.performanceMessage.textContent = message;
            
            // Show weak topics
            generateWeakTopics();
            
            // Show results
            elements.resultContainer.style.display = 'block';
            elements.quizContent.style.display = 'none';
        }
        
        // Generate weak topics analysis
        function generateWeakTopics() {
            const weakTopicsContainer = document.querySelector('.weak-topics');
            // Clear existing topics
            weakTopicsContainer.innerHTML = '<h3><i class="fas fa-exclamation-triangle"></i> Areas for Improvement</h3>';
            
            // Calculate performance per topic
            const topicPerformance = [];
            
            for (const [topic, data] of Object.entries(quizState.weakTopics)) {
                const score = Math.round((data.correct / data.total) * 100);
                topicPerformance.push({ topic, score });
            }
            
            // Sort by worst performance
            topicPerformance.sort((a, b) => a.score - b.score);
            
            // Show top 3 weak topics
            const topWeakTopics = topicPerformance.slice(0, 3);
            
            topWeakTopics.forEach(topic => {
                const topicItem = document.createElement('div');
                topicItem.className = 'topic-item';
                topicItem.innerHTML = `
                    <div class="topic-name">${topic.topic}</div>
                    <div class="topic-score">${100 - topic.score}%</div>
                `;
                
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                
                const progressFill = document.createElement('div');
                progressFill.className = 'progress-fill';
                progressFill.style.width = `${100 - topic.score}%`;
                
                progressBar.appendChild(progressFill);
                
                weakTopicsContainer.appendChild(topicItem);
                weakTopicsContainer.appendChild(progressBar);
            });
        }
        
        // Timer functions
        function startTimer() {
            clearInterval(quizState.timer);
            quizState.timeLeft = 30;
            elements.timeLeft.textContent = quizState.timeLeft;
            
            quizState.timer = setInterval(() => {
                quizState.timeLeft--;
                elements.timeLeft.textContent = quizState.timeLeft;
                
                if (quizState.timeLeft <= 0) {
                    clearInterval(quizState.timer);
                    // Auto move to next question
                    if (quizState.currentQuestionIndex < quizState.questionHistory.length - 1) {
                        nextQuestion();
                    } else {
                        submitQuiz();
                    }
                }
            }, 1000);
        }
        
        function resetTimer() {
            clearInterval(quizState.timer);
            startTimer();
        }
        
        // Event listeners
        elements.nextBtn.addEventListener('click', nextQuestion);
        elements.prevBtn.addEventListener('click', prevQuestion);
        elements.submitBtn.addEventListener('click', submitQuiz);
        elements.restartBtn.addEventListener('click', initQuiz);
        
        // Initialize quiz on page load
        window.addEventListener('DOMContentLoaded', initQuiz);
    </script>
</body>
</html>